/*
 * ISABEL: A group collaboration tool for the Internet
 * Copyright (C) 2009 Agora System S.A.
 * 
 * This file is part of Isabel.
 * 
 * Isabel is free software: you can redistribute it and/or modify
 * it under the terms of the Affero GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * Isabel is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * Affero GNU General Public License for more details.
 * 
 * You should have received a copy of the Affero GNU General Public License
 * along with Isabel.  If not, see <http://www.gnu.org/licenses/>.
 */
/**
 * 
 * Clase que gestiona el servidor de tuneles
 * 
 * @author David Prieto Ruiz
 * @version 0.3
 *
 */

package isabel.tunnel;

import isabel.lib.tasks.Task;
import isabel.lib.tasks.TaskListener;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.FileWriter;
import java.net.DatagramSocket;
import java.net.InetAddress;
import java.net.NetworkInterface;
import java.net.SocketException;
import java.net.UnknownHostException;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Random;

public class ServerTunnel extends TunnelUtils{
   
    /**
     * Tunnel server IP address
     */

    /**
     * Estados:
     * 	0 - Launching
     *  1 - Started
     *  2 - Finished
     */
    private static int status=0;
    
    /**
     * Main method execute launch()
     */
    public static void main(String[] args) {
    	int codigo=launch();
		if (codigo==1){
		   System.out.println("Server tunnel launcher has finished correctly.");
		}else{
		   System.out.println("Server tunnel launcher has finished because an error has happened.");
		}
    }
	
    /**
     * Launch the server tunnel
     * @return Status:
	 *  		- 1 - Started.
	 *  		- 2 - Ended (Error).
     */
    public static int launch() {	
	
	try {
	    
		Hashtable<String, String> clientsInfo = ClientTunnel.getAllClientsInfo();
		
		/*
		 * Comprobamos si hay un tunel lanzado.
		 */
		for (int i = 1;((String)serverInfo().get("STATUS")).equals("STARTING");i++){
			if(i>5){
				System.out.println("ServerTunnel - Time out at starting status - Cleaning sync file.");
				cleanSyncFile();
			}
			Thread.sleep(i*1000);
		}
		
		if (((String)serverInfo().get("STATUS")).equals("STARTED")){
			System.out.println("ServerTunnel - Server is already launched.");
			return 1;
		}

		/*
		 * Reiniciamos los ficheros de sincronizacion.
		 */
		
	    File serverStatusFile = new File (serverStatusFilePath);
	    if (serverStatusFile.exists()){
	    	serverStatusFile.delete();
	    }
	    serverStatusFile.createNewFile();
	    FileWriter serverStatusFileWriter = new FileWriter(serverStatusFile);
	    //serverStatusFileWriter.write(comentaryString + " Status file for server tunnel generated by ServerTunnel at " + new Date() + "\n");
	    serverStatusFileWriter.write("STATUS"  + allocationString + "STARTING" + "\n");
	    serverStatusFileWriter.close();
		
	    File pidFile= new File(serverPidFilePath);
	    if (pidFile.exists()){
	    	pidFile.delete();
	    }
	    
		/*
		 * DIRECCION IP
		 */
		
		//Calculamos la dirección inicial.
	    InetAddress networkIP = null;
	    if ((clientsInfo.get("NUMBER_OF_CLIENTS")).equals("0")){
	    	Random numberGenerator = new Random();
	    	byte[] addressByte = {10,(byte)(numberGenerator.nextInt(214) + 40),(byte)(numberGenerator.nextInt(214) + 40),0};
	    	networkIP = InetAddress.getByAddress(addressByte);
	    	
	    }else{
	    	networkIP = InetAddress.getByName((String)clientsInfo.get("LOCAL_PRIVATE_IP0")); 
	    }
	    
	    // Aseguramos que la direccion tiene el formato adecuado para OpenVPN
	    networkIP = direccion2pool(networkIP);
	    
	    // Elegimos el primer rango valido no utilizado en la maquina
	    while (esDireccionUtilizada(networkIP)){
	    	networkIP= getSiguienteDireccion(networkIP);
	    }
	    
	    // Formamos los strings de direcciones IP definitivos. 
	    String stringNetworkIP = unsignedByte(networkIP.getAddress()[0]) + "." + unsignedByte(networkIP.getAddress()[1]) + "." + unsignedByte(networkIP.getAddress()[2]) + "." + unsignedByte(networkIP.getAddress()[3]);
	    String stringServerIP = unsignedByte(networkIP.getAddress()[0]) + "." + unsignedByte(networkIP.getAddress()[1]) + "." + unsignedByte(networkIP.getAddress()[2]) + "."+ 1;
	    InetAddress serverIP = InetAddress.getByName(stringServerIP);
	    
	    /*
	     * PUERTO
	     */
	    
	    /*
	     * Seleccionamos el puerto en que se lanza la aplicación
	     * Si es posible, será el primero del fichero de puertos.
	     * Si no, será  el puerto predefinido.
	     */
	    int port;
	    boolean portsFileError=false;
	    String line;
	    BufferedReader portsFileReader=null;
	    try {
	    	File portsFile = new File(portsFilePath);
	    	if (!portsFile.exists()){
	    		throw new Exception("ServerTunnel - The ports file (" + portsFilePath + ") doesn't exist.");
	    	}
	    	portsFileReader = new BufferedReader(new FileReader(portsFile));
	    	if ((line=portsFileReader.readLine())==null){
	    		throw new Exception("ServerTunnel - The ports file (" + portsFilePath + ") is empty.");
	    	}else{
	    		port = Integer.parseInt(line.trim());
	    	}
	    }catch (Exception e){
	    	System.out.println("ServerTunnel - Unable to load ports from the ports file (" + portsFilePath + ").");
	    	System.out.println("ServerTunnel - Trying to launch server at predefined port: " + defaultPortServer);
	    	port = defaultPortServer;
	    	portsFileError=true;
	    }
	    
	    System.out.println("Comando que ejecutamos para llamar a openvpn: " + isabelOpenvpnFilePath +
	    			  " " + "server" +
	    			  " " + basicServerTunnelConfigurationFilePath + 
					  " " + serverTunnelLogFilePath + 
					  " " + serverTunnelStatusLogFilePath + 
					  " " + System.getProperty("user.name")+
					  " " + stringNetworkIP +
					  " " + mask +
					  " " + port +
					  " " + serverPidFilePath);
	    
	    /*
	     * LANZAMOS ISABEL_OPENVPN
	     */
	    Task servidorTunel = new Task("server_tunnel",
	    			  isabelOpenvpnFilePath +
	    			  " " + "server" +
	    			  " " + basicServerTunnelConfigurationFilePath + 
					  " " + serverTunnelLogFilePath + 
					  " " + serverTunnelStatusLogFilePath + 
					  " " + System.getProperty("user.name")+
					  " " + stringNetworkIP +
					  " " + mask +
					  " " + port +
					  " " + serverPidFilePath, 
					  false,
					  System.out,
					  System.err);

	    servidorTunel.setDestroyOnKill(false);

	    servidorTunel.addTaskListener(new TaskListener() {
		    
		    public void deadTask(){
			System.out.println("ServerTunnel - OpenVPN server tunnel has finished");
			ServerTunnel.status=2;
		    }
		});
	    servidorTunel.start();
	   
	    //Comprobamos que se ha levantado la interfaz
	    for (int i=1; NetworkInterface.getByInetAddress(serverIP)==null;i++){
		if (status==2){
	    		throw new Exception ("The OpenVPN server tunnel has finished too soon");
		}
	    	if (i==15) {
	    		throw new Exception ("Time out");
		}
	    	Thread.sleep(100*i);
	    }
	    status=1;

	    System.out.println("ServerTunnel - Server tunnel launched successfully at port " + port);
	    

	    /*
	     * SALVAMOS EL FICHERO DE ESTADO DEL SERVIDOR
	     */
	        
	    while (!pidFile.exists()){
	    	Thread.sleep(10);
	    }
	    
	    String pid = "";
	    try{
	    	BufferedReader pidFileReader = new BufferedReader(new FileReader(pidFile));
	    	pid = pidFileReader.readLine().trim();
	    }catch (Exception e){
	    	System.out.println("ServerTunnel - WARNING - There was a problem with the PID file.");
	    }
	    
	    if (serverStatusFile.exists()){
	    	serverStatusFile.delete();
	    }
	    serverStatusFile.createNewFile();
	    serverStatusFileWriter = new FileWriter(serverStatusFile);
	    serverStatusFileWriter.write("STATUS"  + allocationString + "STARTED" + "\n");
	    serverStatusFileWriter.write("INTERFACE"  + allocationString + NetworkInterface.getByInetAddress(serverIP).getName() + "\n");
	    serverStatusFileWriter.write("PRIVATE_IP"  + allocationString + stringServerIP + "\n");
	    serverStatusFileWriter.write("PID"  + allocationString + pid + "\n");
	    serverStatusFileWriter.close();
	    
	    /*
	     * Levantamos las reglas iptables que protegen el servidor
	     */
	    Process firewallUp = Runtime.getRuntime().exec(isabelOpenvpnFilePath + " server_up");
		firewallUp.waitFor();
		if (firewallUp.exitValue()!=0){
			System.out.println("ServerTunnel - WARNING - Unable to turn on server iptables rules");
		}
	    
	    
	    /*
	     * PUERTOS ALTERNATIVOS
	     */

	    //Creamos un fichero para sincronizar los puertos alternativos usados con isabel_openvpn
    	File alternativePortsFile = new File(alternativePortsFilePath);
    	if (alternativePortsFile.exists()){
    		alternativePortsFile.delete();
    	}
    	alternativePortsFile.createNewFile();
    	FileOutputStream fileWriter = new FileOutputStream(alternativePortsFile);
	    
	    //Redirigimos los puertos alternativos hacia el puerto principal si no ocurrio ningun error al leer el fichero de puertos.
    	//OJO: No funciona con direcciones IPv6 porque iptables no lo soporta
    	if(portsFileError){
    		System.out.println("ServerTunnel - Unable to define alternative ports because there was a problem reading ports from " + portsFilePath);
    	}else{
    		int alternativePort;
			while ((line=portsFileReader.readLine())!=null){
				alternativePort=Integer.parseInt(line.trim());
				if (isFreeUDPPort(alternativePort)){
		    		configureAlternativePort(alternativePort,port,fileWriter);
				}else{
		    		System.out.println("ServerTunnel - Alternative port " + alternativePort + " is being used by another application.");
		    	}
	    	}
	    	portsFileReader.close();
    	}
	    fileWriter.close();

	    
	} catch (Exception e) {
	    e.printStackTrace();
	    status=2;
	}
	return status;
    }
    
	
	/**
	 * Close server tunnel
	 * @return true if the tunnel has been closed correctly.  
	 */
	public static boolean stop(){
		boolean ok=false;
		try{
			Hashtable <String, String> server = serverInfo();
			Process kill = Runtime.getRuntime().exec("/bin/kill " + server.get("PID"));
			kill.waitFor();
			if (kill.exitValue()==0){
				ok=true;
			}
		}catch (Exception e){
			System.out.println("TunnelUtils - Unable to close server tunnel.");
			e.printStackTrace();
			ok=false;
		}
		return ok;
	}
	
	/**
	 * Return server tunnel status: STOPPED, STARTING or STARTED
	 * 
	 * @return Status
	 */
	public static String getStatus(){
		return (String) serverInfo().get("STATUS");
	}
	
	/**
	 * Return the server tunnel interface or null if it is not started.
	 * 
	 * @return Server tunnel interface.
	 */
    public static String getInterface(){
    	return (String) serverInfo().get("INTERFACE");
    }
	
    /**
	 * Return the server tunnel private IP address or null if it is not started.
	 * 
	 * @return Server tunnel private IP address.
	 */
    public static String getPrivateIP(){
    	return (String) serverInfo().get("PRIVATE_IP");
    }
    
    
/*
 * MÉTODOS PRIVADOS
 */
    /**
     * Obtiene el siguiente rango de direcciones que podemos utilizar (10.0.0.0 -> 10.0.1.0)
     * @param actual
     * @return
     * @throws UnknownHostException
     */
    private static InetAddress getSiguienteDireccion(InetAddress actual) throws UnknownHostException{
	byte[] byteDireccion = actual.getAddress();
	byteDireccion[2]++;
	if (byteDireccion[2] > 254) byteDireccion[2]=40;
	return InetAddress.getByAddress(byteDireccion); 
    }


    /**
     * Comprueba si una direccion IP esta siendo utilizada en la maquina
     * Antes de comparar aplica a todas las direcciones la mascara 255.255.255.0 
     * @param actual
     * @return
     * @throws SocketException
     * @throws UnknownHostException 
     */
    private static boolean esDireccionUtilizada (InetAddress actual) throws SocketException, UnknownHostException{
	NetworkInterface interfaz;
	InetAddress direccion;
	boolean utilizada = false;
	actual = direccion2pool(actual);
	for (Enumeration interfaces = NetworkInterface.getNetworkInterfaces(); interfaces.hasMoreElements();){
	    interfaz=((NetworkInterface)interfaces.nextElement());
	    for (Enumeration direcciones = interfaz.getInetAddresses(); direcciones.hasMoreElements();){
		direccion = direccion2pool(((InetAddress)direcciones.nextElement()));
		if (direccion.equals(actual))
		    utilizada = true;
	    }
	}
	return utilizada;
    }
    
    private static int unsignedByte (byte b){
	return (b & 0xff);
    }
    
    /**
     * Return if a UDP port is unused.
     * This method can't detect ports 1-1023 without root permissions
     * @param port 
     * @return true if the port isn't being used.
     */
	private static boolean isFreeUDPPortDirectly (int port){
		try{
			DatagramSocket socket = new DatagramSocket(port);
			socket.close();
			return true;
		}catch (Exception e) {
			return false;
		}
	}
	
    /**
     * Return if a UDP port is unused.
     * @param port 
     * @return true if the port isn't being used.
     */
	private static boolean isFreeUDPPort (int port){
		try{
			Process testPort = Runtime.getRuntime().exec(isabelOpenvpnFilePath + " test_UDP_port " + port);
			testPort.waitFor();
						
			if (testPort.exitValue()==1){
				return true;
			}else if (testPort.exitValue()==0){
				return false;
			}else{
				throw new Exception("Invalid value while testing port " + port);
			}
			
		}catch (Exception e) {
			System.out.println(e);
			System.out.println("Error while testing port " + port);
			return false;
		}
	}
	
	private static boolean configureAlternativePort (int port, int mainPort, FileOutputStream fileWriter){
		try{
		    NetworkInterface interfaz;
		    InetAddress direccion;
 		    Process addAlternativePort;
		    
 		    Hashtable <String, String> serverInfo = serverInfo();
 			Hashtable <String, String> clientsInfo = ClientTunnel.getAllClientsInfo();
 		    
		    for (Enumeration interfaces = NetworkInterface.getNetworkInterfaces(); interfaces.hasMoreElements();){
		    	interfaz=(NetworkInterface)interfaces.nextElement();
			
		    	//No aplicamos las reglas iptables a la direccion de localhost
		    	if (interfaz.getName().equals("lo")){
		    		continue;
		    	}
		    	
		    	//No aplicamos las reglas iptables a la direccion del servidor de tuneles.
		    	if (interfaz.getName().equals(serverInfo.get("INTERFACE"))){
		    		continue;
		    	}
		    	
		    	//No aplicamos las reglas iptables a las direcciones de los clientes de tuneles.
		    	boolean clientTunnelInterface=false;
		    	String key;
		    	for (Enumeration keys = clientsInfo.keys(); keys.hasMoreElements();){
		    		key=(String)keys.nextElement();
		    		if (key.startsWith("INTERFACE") && interfaz.getName().equals(clientsInfo.get(key))){
		    			clientTunnelInterface=true;
		    		}
		    	}
		    	if (clientTunnelInterface){
		    		continue;
		    	}
		    	
		    	
				for (Enumeration direcciones = interfaz.getInetAddresses(); direcciones.hasMoreElements();){
					// OJO: No funciona con direcciones IPv6 porque iptables no lo soporta => debatirlo
					direccion = (InetAddress)direcciones.nextElement();
					// Filtramos las direcciones IPv6
					if(direccion.getAddress().length>4)
						continue;
					addAlternativePort = Runtime.getRuntime().exec(isabelOpenvpnFilePath + " add_alternative_port " + direccion.getHostAddress() + " " + port + " " + mainPort);
					addAlternativePort.waitFor();
					if (addAlternativePort.exitValue()==0){
						System.out.println("ServerTunnel - Alternative port " + port + " added successfully at IP address " + direccion.getHostAddress());
						fileWriter.write((direccion.getHostAddress() + " " + port + "\n").getBytes());
					}else{
						System.out.println("ServerTunnel - Alternative port " + port + " COULDN'T be added successfully at IP address " + direccion.getHostAddress());
					}

				}
		    }
			return true;
		}catch(Exception e){
			System.out.println(e);
			return false;
		}
	}
    
    /**
     * Information about the server status. The keys of the Hastable are:
     * 	- STATUS - Values:
     * 		+ STOPPED
     * 		+ STARTING
     * 		+ STARTED
     *  - INTERFACE - Name of the server tunnel interface.
     *  - PRIVATE_IP - private IP address of tunnel.
     *  - PID - Proccess ID
     *    
     * @return Hashtable with the server tunnel status information.
     */
	private static Hashtable<String,String> serverInfo() {
		
		Hashtable<String, String> variables;
		
		try{
			File serverStatusFile = new File(serverStatusFilePath);
			variables = parseStatusFile(serverStatusFile);
			
			//Check parsed variables
			if ((variables.get("STATUS")).equals("STARTING")){
				//Nada que hacer en principio
			}else if((variables.get("STATUS")).equals("STARTED")){
				NetworkInterface interfaz;
			    InetAddress parsedAddress = InetAddress.getByName(variables.get("PRIVATE_IP"));
			    InetAddress address;
			    boolean parseOK = false;
			    for (Enumeration interfaces = NetworkInterface.getNetworkInterfaces(); interfaces.hasMoreElements();){
					interfaz=(NetworkInterface)interfaces.nextElement();
					if (interfaz.getName().equals(variables.get("INTERFACE"))){
					    for (Enumeration direcciones = interfaz.getInetAddresses(); direcciones.hasMoreElements();){
					    	address = (InetAddress)direcciones.nextElement();
					    	if (address.equals(parsedAddress)){
					    		parseOK=true;
					    		break;
					    	}
						}
					}
			    }
				if (!parseOK){
					throw new Exception (serverStatusFilePath + " information is not correct.");
				}
			}else{
				variables = new Hashtable<String, String>();
	    		variables.put("STATUS", "STOPPED"); 
			}
    	}catch(Exception e){
    		//System.out.println("WARNING - Unable to parse server status file (" + serverStatusFilePath +").");
    		variables = new Hashtable<String, String>();
    		variables.put("STATUS", "STOPPED");
    	}
		return variables;
	}
	
	/**
	 * Delete server sync file
	 */
	private static void cleanSyncFile(){
		File syncFile = new File(serverStatusFilePath);
		if (syncFile.exists()){
			syncFile.delete();
		}
	}

}
